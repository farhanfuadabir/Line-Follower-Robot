
LFR_AVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000b38  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00800060  00000b38  00000bcc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000014  00800074  00800074  00000be0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000be0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000c10  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000198  00000000  00000000  00000c4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001013  00000000  00000000  00000de4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000532  00000000  00000000  00001df7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000892  00000000  00000000  00002329  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003d4  00000000  00000000  00002bbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000053d  00000000  00000000  00002f90  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000565  00000000  00000000  000034cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000158  00000000  00000000  00003a32  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 07 04 	jmp	0x80e	; 0x80e <__vector_1>
   8:	0c 94 3a 04 	jmp	0x874	; 0x874 <__vector_2>
   c:	0c 94 85 04 	jmp	0x90a	; 0x90a <__vector_3>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 d4 04 	jmp	0x9a8	; 0x9a8 <__vector_5>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 eb 04 	jmp	0x9d6	; 0x9d6 <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 e3       	ldi	r30, 0x38	; 56
  68:	fb e0       	ldi	r31, 0x0B	; 11
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 37       	cpi	r26, 0x74	; 116
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a4 e7       	ldi	r26, 0x74	; 116
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a8 38       	cpi	r26, 0x88	; 136
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 b7 03 	call	0x76e	; 0x76e <main>
  8a:	0c 94 9a 05 	jmp	0xb34	; 0xb34 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <adc_init>:
  92:	3e 9a       	sbi	0x07, 6	; 7
  94:	37 9a       	sbi	0x06, 7	; 6
  96:	86 b1       	in	r24, 0x06	; 6
  98:	87 60       	ori	r24, 0x07	; 7
  9a:	86 b9       	out	0x06, r24	; 6
  9c:	08 95       	ret

0000009e <adcRead>:
  9e:	97 b1       	in	r25, 0x07	; 7
  a0:	90 7e       	andi	r25, 0xE0	; 224
  a2:	97 b9       	out	0x07, r25	; 7
  a4:	97 b1       	in	r25, 0x07	; 7
  a6:	89 2b       	or	r24, r25
  a8:	87 b9       	out	0x07, r24	; 7
  aa:	36 9a       	sbi	0x06, 6	; 6
  ac:	36 99       	sbic	0x06, 6	; 6
  ae:	fe cf       	rjmp	.-4      	; 0xac <adcRead+0xe>
  b0:	84 b1       	in	r24, 0x04	; 4
  b2:	95 b1       	in	r25, 0x05	; 5
  b4:	08 95       	ret

000000b6 <sensorValueConversion>:
void PID_Correction(void)
{
	error = targetValue - mappedValue;
	sum_error = (sum_error + error) / 2;
	
	correction = ((Kp * error) + (Ki * sum_error) + (Kd * (error - prev_error)));
  b6:	bf 92       	push	r11
  b8:	cf 92       	push	r12
  ba:	df 92       	push	r13
  bc:	ef 92       	push	r14
  be:	ff 92       	push	r15
  c0:	0f 93       	push	r16
  c2:	1f 93       	push	r17
  c4:	cf 93       	push	r28
  c6:	df 93       	push	r29
  c8:	10 92 87 00 	sts	0x0087, r1
  cc:	10 92 86 00 	sts	0x0086, r1
  d0:	04 e7       	ldi	r16, 0x74	; 116
  d2:	10 e0       	ldi	r17, 0x00	; 0
  d4:	c0 e0       	ldi	r28, 0x00	; 0
  d6:	d0 e0       	ldi	r29, 0x00	; 0
  d8:	0f 2e       	mov	r0, r31
  da:	f7 e0       	ldi	r31, 0x07	; 7
  dc:	df 2e       	mov	r13, r31
  de:	f0 2d       	mov	r31, r0
  e0:	ee 24       	eor	r14, r14
  e2:	e3 94       	inc	r14
  e4:	f1 2c       	mov	r15, r1
  e6:	b1 2c       	mov	r11, r1
  e8:	c1 2c       	mov	r12, r1
  ea:	8d 2d       	mov	r24, r13
  ec:	8c 1b       	sub	r24, r28
  ee:	0e 94 4f 00 	call	0x9e	; 0x9e <adcRead>

	prev_error = error;
  f2:	40 91 86 00 	lds	r20, 0x0086
	motorResponse = (int)correction;
  f6:	50 91 87 00 	lds	r21, 0x0087
  fa:	2e 2d       	mov	r18, r14
  fc:	3f 2d       	mov	r19, r15
  fe:	f8 01       	movw	r30, r16
 100:	72 91       	ld	r23, -Z
	
	if(motorResponse > baseSpeed)
 102:	62 91       	ld	r22, -Z
 104:	8f 01       	movw	r16, r30
 106:	86 17       	cp	r24, r22
	{
		reverseSpeed = motorResponse - baseSpeed; 
 108:	97 07       	cpc	r25, r23
		if (reverseSpeed > baseSpeed) reverseSpeed = baseSpeed;
 10a:	10 f4       	brcc	.+4      	; 0x110 <sensorValueConversion+0x5a>
 10c:	2b 2d       	mov	r18, r11
	prev_error = error;
	motorResponse = (int)correction;
	
	if(motorResponse > baseSpeed)
	{
		reverseSpeed = motorResponse - baseSpeed; 
 10e:	3c 2d       	mov	r19, r12
 110:	0c 2e       	mov	r0, r28
 112:	02 c0       	rjmp	.+4      	; 0x118 <sensorValueConversion+0x62>
		if (reverseSpeed > baseSpeed) reverseSpeed = baseSpeed;
 114:	22 0f       	add	r18, r18
 116:	33 1f       	adc	r19, r19
 118:	0a 94       	dec	r0
		motorResponse = baseSpeed;
 11a:	e2 f7       	brpl	.-8      	; 0x114 <sensorValueConversion+0x5e>
 11c:	24 2b       	or	r18, r20
 11e:	35 2b       	or	r19, r21
 120:	30 93 87 00 	sts	0x0087, r19
 124:	20 93 86 00 	sts	0x0086, r18
		
		setRotationLeftSharp();
 128:	6a e0       	ldi	r22, 0x0A	; 10
		
		LMspeed = reverseSpeed;
 12a:	70 e0       	ldi	r23, 0x00	; 0
 12c:	0e 94 3b 05 	call	0xa76	; 0xa76 <Serial_sendInt>
 130:	80 e6       	ldi	r24, 0x60	; 96
		RMspeed = baseSpeed;
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	0e 94 2c 05 	call	0xa58	; 0xa58 <Serial_sendString>
 138:	21 96       	adiw	r28, 0x01	; 1
	}
	
	else if(motorResponse < -baseSpeed) 
 13a:	c8 30       	cpi	r28, 0x08	; 8
 13c:	d1 05       	cpc	r29, r1
 13e:	a9 f6       	brne	.-86     	; 0xea <sensorValueConversion+0x34>
 140:	80 91 86 00 	lds	r24, 0x0086
	{
		reverseSpeed = -motorResponse - baseSpeed;
 144:	90 91 87 00 	lds	r25, 0x0087
		if (reverseSpeed > baseSpeed) reverseSpeed = baseSpeed;
 148:	62 e0       	ldi	r22, 0x02	; 2
 14a:	70 e0       	ldi	r23, 0x00	; 0
		RMspeed = baseSpeed;
	}
	
	else if(motorResponse < -baseSpeed) 
	{
		reverseSpeed = -motorResponse - baseSpeed;
 14c:	0e 94 3b 05 	call	0xa76	; 0xa76 <Serial_sendInt>
 150:	82 e6       	ldi	r24, 0x62	; 98
		if (reverseSpeed > baseSpeed) reverseSpeed = baseSpeed;
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	0e 94 2c 05 	call	0xa58	; 0xa58 <Serial_sendString>
		motorResponse = -baseSpeed;
 158:	df 91       	pop	r29
 15a:	cf 91       	pop	r28
 15c:	1f 91       	pop	r17
 15e:	0f 91       	pop	r16
 160:	ff 90       	pop	r15
 162:	ef 90       	pop	r14
		
		setRotationRightSharp();
 164:	df 90       	pop	r13
 166:	cf 90       	pop	r12
		
		LMspeed = baseSpeed;
 168:	bf 90       	pop	r11
 16a:	08 95       	ret

0000016c <sensorMapping>:
 16c:	80 91 86 00 	lds	r24, 0x0086
		RMspeed = reverseSpeed;
 170:	90 91 87 00 	lds	r25, 0x0087
 174:	89 2b       	or	r24, r25
 176:	09 f4       	brne	.+2      	; 0x17a <sensorMapping+0xe>
	}
	
	else if(motorResponse > -baseSpeed && motorResponse < baseSpeed)
 178:	a5 c2       	rjmp	.+1354   	; 0x6c4 <sensorMapping+0x558>
 17a:	80 91 86 00 	lds	r24, 0x0086
 17e:	90 91 87 00 	lds	r25, 0x0087
	{
		setRotationForward();
 182:	80 91 86 00 	lds	r24, 0x0086
		
		LMspeed = baseSpeed - motorResponse;
 186:	90 91 87 00 	lds	r25, 0x0087
 18a:	8f 3f       	cpi	r24, 0xFF	; 255
 18c:	91 05       	cpc	r25, r1
 18e:	09 f4       	brne	.+2      	; 0x192 <sensorMapping+0x26>
 190:	99 c2       	rjmp	.+1330   	; 0x6c4 <sensorMapping+0x558>
		RMspeed = baseSpeed + motorResponse;
 192:	80 91 86 00 	lds	r24, 0x0086
 196:	90 91 87 00 	lds	r25, 0x0087
		if (LMspeed > maxSpeed) LMspeed = maxSpeed;
		else if (LMspeed > maxSpeed) LMspeed = maxSpeed;
	}
}
 19a:	49 97       	sbiw	r24, 0x19	; 25
 19c:	01 f1       	breq	.+64     	; 0x1de <sensorMapping+0x72>
 19e:	80 91 86 00 	lds	r24, 0x0086
 1a2:	90 91 87 00 	lds	r25, 0x0087
 1a6:	09 97       	sbiw	r24, 0x09	; 9
 1a8:	d1 f0       	breq	.+52     	; 0x1de <sensorMapping+0x72>
 1aa:	80 91 86 00 	lds	r24, 0x0086
 1ae:	90 91 87 00 	lds	r25, 0x0087
void sensorMapping(void)
{
	if (sensorValue == 0b00000000 || sensorValue == 01100110);
	else if (sensorValue == 0b11111111);
	
	else if ((sensorValue == 0b00011001) || (sensorValue == 0b00001001) || (sensorValue == 0b00010001) || (sensorValue == 0b00110001) || (sensorValue == 0b01110001) || (sensorValue == 0b01100011)) mappedValue = 120;
 1b2:	41 97       	sbiw	r24, 0x11	; 17
 1b4:	a1 f0       	breq	.+40     	; 0x1de <sensorMapping+0x72>
 1b6:	80 91 86 00 	lds	r24, 0x0086
 1ba:	90 91 87 00 	lds	r25, 0x0087
 1be:	c1 97       	sbiw	r24, 0x31	; 49
 1c0:	71 f0       	breq	.+28     	; 0x1de <sensorMapping+0x72>
 1c2:	80 91 86 00 	lds	r24, 0x0086
 1c6:	90 91 87 00 	lds	r25, 0x0087
 1ca:	81 37       	cpi	r24, 0x71	; 113
 1cc:	91 05       	cpc	r25, r1
 1ce:	39 f0       	breq	.+14     	; 0x1de <sensorMapping+0x72>
 1d0:	80 91 86 00 	lds	r24, 0x0086
 1d4:	90 91 87 00 	lds	r25, 0x0087
 1d8:	83 36       	cpi	r24, 0x63	; 99
 1da:	91 05       	cpc	r25, r1
 1dc:	39 f4       	brne	.+14     	; 0x1ec <sensorMapping+0x80>
 1de:	88 e7       	ldi	r24, 0x78	; 120
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	90 93 85 00 	sts	0x0085, r25
 1e6:	80 93 84 00 	sts	0x0084, r24
 1ea:	08 95       	ret
	else if ((sensorValue == 0b00001011) || (sensorValue == 0b00010011) || (sensorValue == 0b00011011) || (sensorValue == 0b00001010) || (sensorValue == 0b00010010) || (sensorValue == 0b01110111) || (sensorValue == 0b01110011) || (sensorValue == 0b00110111) || (sensorValue == 0b00011101) || (sensorValue == 0b01100111) || (sensorValue == 0b00001101) || (sensorValue == 0b00111001) || (sensorValue == 0b00110011)) mappedValue = 120;
 1ec:	80 91 86 00 	lds	r24, 0x0086
 1f0:	90 91 87 00 	lds	r25, 0x0087
 1f4:	0b 97       	sbiw	r24, 0x0b	; 11
 1f6:	09 f4       	brne	.+2      	; 0x1fa <sensorMapping+0x8e>
 1f8:	4d c0       	rjmp	.+154    	; 0x294 <sensorMapping+0x128>
 1fa:	80 91 86 00 	lds	r24, 0x0086
 1fe:	90 91 87 00 	lds	r25, 0x0087
 202:	43 97       	sbiw	r24, 0x13	; 19
 204:	09 f4       	brne	.+2      	; 0x208 <sensorMapping+0x9c>
 206:	46 c0       	rjmp	.+140    	; 0x294 <sensorMapping+0x128>
 208:	80 91 86 00 	lds	r24, 0x0086
 20c:	90 91 87 00 	lds	r25, 0x0087
 210:	4b 97       	sbiw	r24, 0x1b	; 27
 212:	09 f4       	brne	.+2      	; 0x216 <sensorMapping+0xaa>
 214:	3f c0       	rjmp	.+126    	; 0x294 <sensorMapping+0x128>
 216:	80 91 86 00 	lds	r24, 0x0086
 21a:	90 91 87 00 	lds	r25, 0x0087
 21e:	0a 97       	sbiw	r24, 0x0a	; 10
 220:	c9 f1       	breq	.+114    	; 0x294 <sensorMapping+0x128>
 222:	80 91 86 00 	lds	r24, 0x0086
 226:	90 91 87 00 	lds	r25, 0x0087
 22a:	42 97       	sbiw	r24, 0x12	; 18
 22c:	99 f1       	breq	.+102    	; 0x294 <sensorMapping+0x128>
 22e:	80 91 86 00 	lds	r24, 0x0086
 232:	90 91 87 00 	lds	r25, 0x0087
 236:	87 37       	cpi	r24, 0x77	; 119
 238:	91 05       	cpc	r25, r1
 23a:	61 f1       	breq	.+88     	; 0x294 <sensorMapping+0x128>
 23c:	80 91 86 00 	lds	r24, 0x0086
 240:	90 91 87 00 	lds	r25, 0x0087
 244:	83 37       	cpi	r24, 0x73	; 115
 246:	91 05       	cpc	r25, r1
 248:	29 f1       	breq	.+74     	; 0x294 <sensorMapping+0x128>
 24a:	80 91 86 00 	lds	r24, 0x0086
 24e:	90 91 87 00 	lds	r25, 0x0087
 252:	c7 97       	sbiw	r24, 0x37	; 55
 254:	f9 f0       	breq	.+62     	; 0x294 <sensorMapping+0x128>
 256:	80 91 86 00 	lds	r24, 0x0086
 25a:	90 91 87 00 	lds	r25, 0x0087
 25e:	4d 97       	sbiw	r24, 0x1d	; 29
 260:	c9 f0       	breq	.+50     	; 0x294 <sensorMapping+0x128>
 262:	80 91 86 00 	lds	r24, 0x0086
 266:	90 91 87 00 	lds	r25, 0x0087
 26a:	87 36       	cpi	r24, 0x67	; 103
 26c:	91 05       	cpc	r25, r1
 26e:	91 f0       	breq	.+36     	; 0x294 <sensorMapping+0x128>
 270:	80 91 86 00 	lds	r24, 0x0086
 274:	90 91 87 00 	lds	r25, 0x0087
 278:	0d 97       	sbiw	r24, 0x0d	; 13
 27a:	61 f0       	breq	.+24     	; 0x294 <sensorMapping+0x128>
 27c:	80 91 86 00 	lds	r24, 0x0086
 280:	90 91 87 00 	lds	r25, 0x0087
 284:	c9 97       	sbiw	r24, 0x39	; 57
 286:	31 f0       	breq	.+12     	; 0x294 <sensorMapping+0x128>
 288:	80 91 86 00 	lds	r24, 0x0086
 28c:	90 91 87 00 	lds	r25, 0x0087
 290:	c3 97       	sbiw	r24, 0x33	; 51
 292:	39 f4       	brne	.+14     	; 0x2a2 <sensorMapping+0x136>
 294:	88 e7       	ldi	r24, 0x78	; 120
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	90 93 85 00 	sts	0x0085, r25
 29c:	80 93 84 00 	sts	0x0084, r24
 2a0:	08 95       	ret
	else if ((sensorValue == 0b00001111) || (sensorValue == 0b00011111)) mappedValue = 100;
 2a2:	80 91 86 00 	lds	r24, 0x0086
 2a6:	90 91 87 00 	lds	r25, 0x0087
 2aa:	0f 97       	sbiw	r24, 0x0f	; 15
 2ac:	31 f0       	breq	.+12     	; 0x2ba <sensorMapping+0x14e>
 2ae:	80 91 86 00 	lds	r24, 0x0086
 2b2:	90 91 87 00 	lds	r25, 0x0087
 2b6:	4f 97       	sbiw	r24, 0x1f	; 31
 2b8:	39 f4       	brne	.+14     	; 0x2c8 <sensorMapping+0x15c>
 2ba:	84 e6       	ldi	r24, 0x64	; 100
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	90 93 85 00 	sts	0x0085, r25
 2c2:	80 93 84 00 	sts	0x0084, r24
 2c6:	08 95       	ret
	else if (sensorValue == 0b00000001 || sensorValue == 0b11111110) mappedValue = 70;
 2c8:	80 91 86 00 	lds	r24, 0x0086
 2cc:	90 91 87 00 	lds	r25, 0x0087
 2d0:	01 97       	sbiw	r24, 0x01	; 1
 2d2:	39 f0       	breq	.+14     	; 0x2e2 <sensorMapping+0x176>
 2d4:	80 91 86 00 	lds	r24, 0x0086
 2d8:	90 91 87 00 	lds	r25, 0x0087
 2dc:	8e 3f       	cpi	r24, 0xFE	; 254
 2de:	91 05       	cpc	r25, r1
 2e0:	39 f4       	brne	.+14     	; 0x2f0 <sensorMapping+0x184>
 2e2:	86 e4       	ldi	r24, 0x46	; 70
 2e4:	90 e0       	ldi	r25, 0x00	; 0
 2e6:	90 93 85 00 	sts	0x0085, r25
 2ea:	80 93 84 00 	sts	0x0084, r24
 2ee:	08 95       	ret
	else if (sensorValue == 0b00000011 || sensorValue == 0b11111100) mappedValue = 60;
 2f0:	80 91 86 00 	lds	r24, 0x0086
 2f4:	90 91 87 00 	lds	r25, 0x0087
 2f8:	03 97       	sbiw	r24, 0x03	; 3
 2fa:	39 f0       	breq	.+14     	; 0x30a <sensorMapping+0x19e>
 2fc:	80 91 86 00 	lds	r24, 0x0086
 300:	90 91 87 00 	lds	r25, 0x0087
 304:	8c 3f       	cpi	r24, 0xFC	; 252
 306:	91 05       	cpc	r25, r1
 308:	39 f4       	brne	.+14     	; 0x318 <sensorMapping+0x1ac>
 30a:	8c e3       	ldi	r24, 0x3C	; 60
 30c:	90 e0       	ldi	r25, 0x00	; 0
 30e:	90 93 85 00 	sts	0x0085, r25
 312:	80 93 84 00 	sts	0x0084, r24
 316:	08 95       	ret
	else if (sensorValue == 0b00000010 || sensorValue == 0b00000111 || sensorValue == 0b11111101) mappedValue = 50;
 318:	80 91 86 00 	lds	r24, 0x0086
 31c:	90 91 87 00 	lds	r25, 0x0087
 320:	02 97       	sbiw	r24, 0x02	; 2
 322:	69 f0       	breq	.+26     	; 0x33e <sensorMapping+0x1d2>
 324:	80 91 86 00 	lds	r24, 0x0086
 328:	90 91 87 00 	lds	r25, 0x0087
 32c:	07 97       	sbiw	r24, 0x07	; 7
 32e:	39 f0       	breq	.+14     	; 0x33e <sensorMapping+0x1d2>
 330:	80 91 86 00 	lds	r24, 0x0086
 334:	90 91 87 00 	lds	r25, 0x0087
 338:	8d 3f       	cpi	r24, 0xFD	; 253
 33a:	91 05       	cpc	r25, r1
 33c:	39 f4       	brne	.+14     	; 0x34c <sensorMapping+0x1e0>
 33e:	82 e3       	ldi	r24, 0x32	; 50
 340:	90 e0       	ldi	r25, 0x00	; 0
 342:	90 93 85 00 	sts	0x0085, r25
 346:	80 93 84 00 	sts	0x0084, r24
 34a:	08 95       	ret
	else if (sensorValue == 0b00000110 || sensorValue == 0b11111001) mappedValue = 40;
 34c:	80 91 86 00 	lds	r24, 0x0086
 350:	90 91 87 00 	lds	r25, 0x0087
 354:	06 97       	sbiw	r24, 0x06	; 6
 356:	39 f0       	breq	.+14     	; 0x366 <sensorMapping+0x1fa>
 358:	80 91 86 00 	lds	r24, 0x0086
 35c:	90 91 87 00 	lds	r25, 0x0087
 360:	89 3f       	cpi	r24, 0xF9	; 249
 362:	91 05       	cpc	r25, r1
 364:	39 f4       	brne	.+14     	; 0x374 <sensorMapping+0x208>
 366:	88 e2       	ldi	r24, 0x28	; 40
 368:	90 e0       	ldi	r25, 0x00	; 0
 36a:	90 93 85 00 	sts	0x0085, r25
 36e:	80 93 84 00 	sts	0x0084, r24
 372:	08 95       	ret
	else if (sensorValue == 0b00000100 || sensorValue == 0b00001110 || sensorValue == 0b11111011) mappedValue = 30;
 374:	80 91 86 00 	lds	r24, 0x0086
 378:	90 91 87 00 	lds	r25, 0x0087
 37c:	04 97       	sbiw	r24, 0x04	; 4
 37e:	69 f0       	breq	.+26     	; 0x39a <sensorMapping+0x22e>
 380:	80 91 86 00 	lds	r24, 0x0086
 384:	90 91 87 00 	lds	r25, 0x0087
 388:	0e 97       	sbiw	r24, 0x0e	; 14
 38a:	39 f0       	breq	.+14     	; 0x39a <sensorMapping+0x22e>
 38c:	80 91 86 00 	lds	r24, 0x0086
 390:	90 91 87 00 	lds	r25, 0x0087
 394:	8b 3f       	cpi	r24, 0xFB	; 251
 396:	91 05       	cpc	r25, r1
 398:	39 f4       	brne	.+14     	; 0x3a8 <sensorMapping+0x23c>
 39a:	8e e1       	ldi	r24, 0x1E	; 30
 39c:	90 e0       	ldi	r25, 0x00	; 0
 39e:	90 93 85 00 	sts	0x0085, r25
 3a2:	80 93 84 00 	sts	0x0084, r24
 3a6:	08 95       	ret
	else if (sensorValue == 0b00001100 || sensorValue == 0b11110011) mappedValue = 20;
 3a8:	80 91 86 00 	lds	r24, 0x0086
 3ac:	90 91 87 00 	lds	r25, 0x0087
 3b0:	0c 97       	sbiw	r24, 0x0c	; 12
 3b2:	39 f0       	breq	.+14     	; 0x3c2 <sensorMapping+0x256>
 3b4:	80 91 86 00 	lds	r24, 0x0086
 3b8:	90 91 87 00 	lds	r25, 0x0087
 3bc:	83 3f       	cpi	r24, 0xF3	; 243
 3be:	91 05       	cpc	r25, r1
 3c0:	39 f4       	brne	.+14     	; 0x3d0 <sensorMapping+0x264>
 3c2:	84 e1       	ldi	r24, 0x14	; 20
 3c4:	90 e0       	ldi	r25, 0x00	; 0
 3c6:	90 93 85 00 	sts	0x0085, r25
 3ca:	80 93 84 00 	sts	0x0084, r24
 3ce:	08 95       	ret
	else if (sensorValue == 0b00001000 || sensorValue == 0b00011100 || sensorValue == 0b11110111) mappedValue = 10;
 3d0:	80 91 86 00 	lds	r24, 0x0086
 3d4:	90 91 87 00 	lds	r25, 0x0087
 3d8:	08 97       	sbiw	r24, 0x08	; 8
 3da:	69 f0       	breq	.+26     	; 0x3f6 <sensorMapping+0x28a>
 3dc:	80 91 86 00 	lds	r24, 0x0086
 3e0:	90 91 87 00 	lds	r25, 0x0087
 3e4:	4c 97       	sbiw	r24, 0x1c	; 28
 3e6:	39 f0       	breq	.+14     	; 0x3f6 <sensorMapping+0x28a>
 3e8:	80 91 86 00 	lds	r24, 0x0086
 3ec:	90 91 87 00 	lds	r25, 0x0087
 3f0:	87 3f       	cpi	r24, 0xF7	; 247
 3f2:	91 05       	cpc	r25, r1
 3f4:	39 f4       	brne	.+14     	; 0x404 <sensorMapping+0x298>
 3f6:	8a e0       	ldi	r24, 0x0A	; 10
 3f8:	90 e0       	ldi	r25, 0x00	; 0
 3fa:	90 93 85 00 	sts	0x0085, r25
 3fe:	80 93 84 00 	sts	0x0084, r24
 402:	08 95       	ret
	else if (sensorValue == 0b00011000 || sensorValue == 0b11100111) mappedValue = 0;
 404:	80 91 86 00 	lds	r24, 0x0086
 408:	90 91 87 00 	lds	r25, 0x0087
 40c:	48 97       	sbiw	r24, 0x18	; 24
 40e:	39 f0       	breq	.+14     	; 0x41e <sensorMapping+0x2b2>
 410:	80 91 86 00 	lds	r24, 0x0086
 414:	90 91 87 00 	lds	r25, 0x0087
 418:	87 3e       	cpi	r24, 0xE7	; 231
 41a:	91 05       	cpc	r25, r1
 41c:	29 f4       	brne	.+10     	; 0x428 <sensorMapping+0x2bc>
 41e:	10 92 85 00 	sts	0x0085, r1
 422:	10 92 84 00 	sts	0x0084, r1
 426:	08 95       	ret
	else if (sensorValue == 0b00010000 || sensorValue == 0b00111000 || sensorValue == 0b11101111) mappedValue = -10;
 428:	80 91 86 00 	lds	r24, 0x0086
 42c:	90 91 87 00 	lds	r25, 0x0087
 430:	40 97       	sbiw	r24, 0x10	; 16
 432:	69 f0       	breq	.+26     	; 0x44e <sensorMapping+0x2e2>
 434:	80 91 86 00 	lds	r24, 0x0086
 438:	90 91 87 00 	lds	r25, 0x0087
 43c:	c8 97       	sbiw	r24, 0x38	; 56
 43e:	39 f0       	breq	.+14     	; 0x44e <sensorMapping+0x2e2>
 440:	80 91 86 00 	lds	r24, 0x0086
 444:	90 91 87 00 	lds	r25, 0x0087
 448:	8f 3e       	cpi	r24, 0xEF	; 239
 44a:	91 05       	cpc	r25, r1
 44c:	39 f4       	brne	.+14     	; 0x45c <sensorMapping+0x2f0>
 44e:	86 ef       	ldi	r24, 0xF6	; 246
 450:	9f ef       	ldi	r25, 0xFF	; 255
 452:	90 93 85 00 	sts	0x0085, r25
 456:	80 93 84 00 	sts	0x0084, r24
 45a:	08 95       	ret
	else if (sensorValue == 0b00110000 || sensorValue == 0b11001111) mappedValue = -20;
 45c:	80 91 86 00 	lds	r24, 0x0086
 460:	90 91 87 00 	lds	r25, 0x0087
 464:	c0 97       	sbiw	r24, 0x30	; 48
 466:	39 f0       	breq	.+14     	; 0x476 <sensorMapping+0x30a>
 468:	80 91 86 00 	lds	r24, 0x0086
 46c:	90 91 87 00 	lds	r25, 0x0087
 470:	8f 3c       	cpi	r24, 0xCF	; 207
 472:	91 05       	cpc	r25, r1
 474:	39 f4       	brne	.+14     	; 0x484 <sensorMapping+0x318>
 476:	8c ee       	ldi	r24, 0xEC	; 236
 478:	9f ef       	ldi	r25, 0xFF	; 255
 47a:	90 93 85 00 	sts	0x0085, r25
 47e:	80 93 84 00 	sts	0x0084, r24
 482:	08 95       	ret
	else if (sensorValue == 0b00100000 || sensorValue == 0b01110000 || sensorValue == 0b11011111) mappedValue = -30;
 484:	80 91 86 00 	lds	r24, 0x0086
 488:	90 91 87 00 	lds	r25, 0x0087
 48c:	80 97       	sbiw	r24, 0x20	; 32
 48e:	71 f0       	breq	.+28     	; 0x4ac <sensorMapping+0x340>
 490:	80 91 86 00 	lds	r24, 0x0086
 494:	90 91 87 00 	lds	r25, 0x0087
 498:	80 37       	cpi	r24, 0x70	; 112
 49a:	91 05       	cpc	r25, r1
 49c:	39 f0       	breq	.+14     	; 0x4ac <sensorMapping+0x340>
 49e:	80 91 86 00 	lds	r24, 0x0086
 4a2:	90 91 87 00 	lds	r25, 0x0087
 4a6:	8f 3d       	cpi	r24, 0xDF	; 223
 4a8:	91 05       	cpc	r25, r1
 4aa:	39 f4       	brne	.+14     	; 0x4ba <sensorMapping+0x34e>
 4ac:	82 ee       	ldi	r24, 0xE2	; 226
 4ae:	9f ef       	ldi	r25, 0xFF	; 255
 4b0:	90 93 85 00 	sts	0x0085, r25
 4b4:	80 93 84 00 	sts	0x0084, r24
 4b8:	08 95       	ret
	else if (sensorValue == 0b01100000 || sensorValue == 0b10011111) mappedValue = -40;
 4ba:	80 91 86 00 	lds	r24, 0x0086
 4be:	90 91 87 00 	lds	r25, 0x0087
 4c2:	80 36       	cpi	r24, 0x60	; 96
 4c4:	91 05       	cpc	r25, r1
 4c6:	39 f0       	breq	.+14     	; 0x4d6 <sensorMapping+0x36a>
 4c8:	80 91 86 00 	lds	r24, 0x0086
 4cc:	90 91 87 00 	lds	r25, 0x0087
 4d0:	8f 39       	cpi	r24, 0x9F	; 159
 4d2:	91 05       	cpc	r25, r1
 4d4:	39 f4       	brne	.+14     	; 0x4e4 <sensorMapping+0x378>
 4d6:	88 ed       	ldi	r24, 0xD8	; 216
 4d8:	9f ef       	ldi	r25, 0xFF	; 255
 4da:	90 93 85 00 	sts	0x0085, r25
 4de:	80 93 84 00 	sts	0x0084, r24
 4e2:	08 95       	ret
	else if (sensorValue == 0b01000000 || sensorValue == 0b11100000 || sensorValue == 0b10111111) mappedValue = -50;
 4e4:	80 91 86 00 	lds	r24, 0x0086
 4e8:	90 91 87 00 	lds	r25, 0x0087
 4ec:	80 34       	cpi	r24, 0x40	; 64
 4ee:	91 05       	cpc	r25, r1
 4f0:	71 f0       	breq	.+28     	; 0x50e <sensorMapping+0x3a2>
 4f2:	80 91 86 00 	lds	r24, 0x0086
 4f6:	90 91 87 00 	lds	r25, 0x0087
 4fa:	80 3e       	cpi	r24, 0xE0	; 224
 4fc:	91 05       	cpc	r25, r1
 4fe:	39 f0       	breq	.+14     	; 0x50e <sensorMapping+0x3a2>
 500:	80 91 86 00 	lds	r24, 0x0086
 504:	90 91 87 00 	lds	r25, 0x0087
 508:	8f 3b       	cpi	r24, 0xBF	; 191
 50a:	91 05       	cpc	r25, r1
 50c:	39 f4       	brne	.+14     	; 0x51c <sensorMapping+0x3b0>
 50e:	8e ec       	ldi	r24, 0xCE	; 206
 510:	9f ef       	ldi	r25, 0xFF	; 255
 512:	90 93 85 00 	sts	0x0085, r25
 516:	80 93 84 00 	sts	0x0084, r24
 51a:	08 95       	ret
	else if (sensorValue == 0b11000000 || sensorValue == 0b00111111) mappedValue = -60;
 51c:	80 91 86 00 	lds	r24, 0x0086
 520:	90 91 87 00 	lds	r25, 0x0087
 524:	80 3c       	cpi	r24, 0xC0	; 192
 526:	91 05       	cpc	r25, r1
 528:	31 f0       	breq	.+12     	; 0x536 <sensorMapping+0x3ca>
 52a:	80 91 86 00 	lds	r24, 0x0086
 52e:	90 91 87 00 	lds	r25, 0x0087
 532:	cf 97       	sbiw	r24, 0x3f	; 63
 534:	39 f4       	brne	.+14     	; 0x544 <sensorMapping+0x3d8>
 536:	84 ec       	ldi	r24, 0xC4	; 196
 538:	9f ef       	ldi	r25, 0xFF	; 255
 53a:	90 93 85 00 	sts	0x0085, r25
 53e:	80 93 84 00 	sts	0x0084, r24
 542:	08 95       	ret
	else if (sensorValue == 0b10000000 || sensorValue == 0b01111111) mappedValue = -70;
 544:	80 91 86 00 	lds	r24, 0x0086
 548:	90 91 87 00 	lds	r25, 0x0087
 54c:	80 38       	cpi	r24, 0x80	; 128
 54e:	91 05       	cpc	r25, r1
 550:	39 f0       	breq	.+14     	; 0x560 <sensorMapping+0x3f4>
 552:	80 91 86 00 	lds	r24, 0x0086
 556:	90 91 87 00 	lds	r25, 0x0087
 55a:	8f 37       	cpi	r24, 0x7F	; 127
 55c:	91 05       	cpc	r25, r1
 55e:	39 f4       	brne	.+14     	; 0x56e <sensorMapping+0x402>
 560:	8a eb       	ldi	r24, 0xBA	; 186
 562:	9f ef       	ldi	r25, 0xFF	; 255
 564:	90 93 85 00 	sts	0x0085, r25
 568:	80 93 84 00 	sts	0x0084, r24
 56c:	08 95       	ret
	else if ((sensorValue == 0b11110000) || (sensorValue == 0b11111000)) mappedValue = -100;
 56e:	80 91 86 00 	lds	r24, 0x0086
 572:	90 91 87 00 	lds	r25, 0x0087
 576:	80 3f       	cpi	r24, 0xF0	; 240
 578:	91 05       	cpc	r25, r1
 57a:	39 f0       	breq	.+14     	; 0x58a <sensorMapping+0x41e>
 57c:	80 91 86 00 	lds	r24, 0x0086
 580:	90 91 87 00 	lds	r25, 0x0087
 584:	88 3f       	cpi	r24, 0xF8	; 248
 586:	91 05       	cpc	r25, r1
 588:	39 f4       	brne	.+14     	; 0x598 <sensorMapping+0x42c>
 58a:	8c e9       	ldi	r24, 0x9C	; 156
 58c:	9f ef       	ldi	r25, 0xFF	; 255
 58e:	90 93 85 00 	sts	0x0085, r25
 592:	80 93 84 00 	sts	0x0084, r24
 596:	08 95       	ret
	else if ((sensorValue == 0b11011000) || (sensorValue == 0b11010000) || (sensorValue == 0b11001000) || (sensorValue == 0b01010000) || (sensorValue == 0b01001000) || (sensorValue == 0b11101110) || (sensorValue == 0b11001110) || (sensorValue == 0b11101100) || (sensorValue == 0b10111000) || (sensorValue == 0b11100110) || (sensorValue == 0b10110000) || (sensorValue == 0b10011100) || (sensorValue == 0b11001100)) mappedValue = -120;
 598:	80 91 86 00 	lds	r24, 0x0086
 59c:	90 91 87 00 	lds	r25, 0x0087
 5a0:	88 3d       	cpi	r24, 0xD8	; 216
 5a2:	91 05       	cpc	r25, r1
 5a4:	09 f4       	brne	.+2      	; 0x5a8 <sensorMapping+0x43c>
 5a6:	57 c0       	rjmp	.+174    	; 0x656 <sensorMapping+0x4ea>
 5a8:	80 91 86 00 	lds	r24, 0x0086
 5ac:	90 91 87 00 	lds	r25, 0x0087
 5b0:	80 3d       	cpi	r24, 0xD0	; 208
 5b2:	91 05       	cpc	r25, r1
 5b4:	09 f4       	brne	.+2      	; 0x5b8 <sensorMapping+0x44c>
 5b6:	4f c0       	rjmp	.+158    	; 0x656 <sensorMapping+0x4ea>
 5b8:	80 91 86 00 	lds	r24, 0x0086
 5bc:	90 91 87 00 	lds	r25, 0x0087
 5c0:	88 3c       	cpi	r24, 0xC8	; 200
 5c2:	91 05       	cpc	r25, r1
 5c4:	09 f4       	brne	.+2      	; 0x5c8 <sensorMapping+0x45c>
 5c6:	47 c0       	rjmp	.+142    	; 0x656 <sensorMapping+0x4ea>
 5c8:	80 91 86 00 	lds	r24, 0x0086
 5cc:	90 91 87 00 	lds	r25, 0x0087
 5d0:	80 35       	cpi	r24, 0x50	; 80
 5d2:	91 05       	cpc	r25, r1
 5d4:	09 f4       	brne	.+2      	; 0x5d8 <sensorMapping+0x46c>
 5d6:	3f c0       	rjmp	.+126    	; 0x656 <sensorMapping+0x4ea>
 5d8:	80 91 86 00 	lds	r24, 0x0086
 5dc:	90 91 87 00 	lds	r25, 0x0087
 5e0:	88 34       	cpi	r24, 0x48	; 72
 5e2:	91 05       	cpc	r25, r1
 5e4:	c1 f1       	breq	.+112    	; 0x656 <sensorMapping+0x4ea>
 5e6:	80 91 86 00 	lds	r24, 0x0086
 5ea:	90 91 87 00 	lds	r25, 0x0087
 5ee:	8e 3e       	cpi	r24, 0xEE	; 238
 5f0:	91 05       	cpc	r25, r1
 5f2:	89 f1       	breq	.+98     	; 0x656 <sensorMapping+0x4ea>
 5f4:	80 91 86 00 	lds	r24, 0x0086
 5f8:	90 91 87 00 	lds	r25, 0x0087
 5fc:	8e 3c       	cpi	r24, 0xCE	; 206
 5fe:	91 05       	cpc	r25, r1
 600:	51 f1       	breq	.+84     	; 0x656 <sensorMapping+0x4ea>
 602:	80 91 86 00 	lds	r24, 0x0086
 606:	90 91 87 00 	lds	r25, 0x0087
 60a:	8c 3e       	cpi	r24, 0xEC	; 236
 60c:	91 05       	cpc	r25, r1
 60e:	19 f1       	breq	.+70     	; 0x656 <sensorMapping+0x4ea>
 610:	80 91 86 00 	lds	r24, 0x0086
 614:	90 91 87 00 	lds	r25, 0x0087
 618:	88 3b       	cpi	r24, 0xB8	; 184
 61a:	91 05       	cpc	r25, r1
 61c:	e1 f0       	breq	.+56     	; 0x656 <sensorMapping+0x4ea>
 61e:	80 91 86 00 	lds	r24, 0x0086
 622:	90 91 87 00 	lds	r25, 0x0087
 626:	86 3e       	cpi	r24, 0xE6	; 230
 628:	91 05       	cpc	r25, r1
 62a:	a9 f0       	breq	.+42     	; 0x656 <sensorMapping+0x4ea>
 62c:	80 91 86 00 	lds	r24, 0x0086
 630:	90 91 87 00 	lds	r25, 0x0087
 634:	80 3b       	cpi	r24, 0xB0	; 176
 636:	91 05       	cpc	r25, r1
 638:	71 f0       	breq	.+28     	; 0x656 <sensorMapping+0x4ea>
 63a:	80 91 86 00 	lds	r24, 0x0086
 63e:	90 91 87 00 	lds	r25, 0x0087
 642:	8c 39       	cpi	r24, 0x9C	; 156
 644:	91 05       	cpc	r25, r1
 646:	39 f0       	breq	.+14     	; 0x656 <sensorMapping+0x4ea>
 648:	80 91 86 00 	lds	r24, 0x0086
 64c:	90 91 87 00 	lds	r25, 0x0087
 650:	8c 3c       	cpi	r24, 0xCC	; 204
 652:	91 05       	cpc	r25, r1
 654:	39 f4       	brne	.+14     	; 0x664 <sensorMapping+0x4f8>
 656:	88 e8       	ldi	r24, 0x88	; 136
 658:	9f ef       	ldi	r25, 0xFF	; 255
 65a:	90 93 85 00 	sts	0x0085, r25
 65e:	80 93 84 00 	sts	0x0084, r24
 662:	08 95       	ret
	else if ((sensorValue == 0b10011000) || (sensorValue == 0b10010000) || (sensorValue == 0b10001000) || (sensorValue == 0b10001100) || (sensorValue == 0b10001110) || (sensorValue == 0b11000110)) mappedValue = -120;
 664:	80 91 86 00 	lds	r24, 0x0086
 668:	90 91 87 00 	lds	r25, 0x0087
 66c:	88 39       	cpi	r24, 0x98	; 152
 66e:	91 05       	cpc	r25, r1
 670:	19 f1       	breq	.+70     	; 0x6b8 <sensorMapping+0x54c>
 672:	80 91 86 00 	lds	r24, 0x0086
 676:	90 91 87 00 	lds	r25, 0x0087
 67a:	80 39       	cpi	r24, 0x90	; 144
 67c:	91 05       	cpc	r25, r1
 67e:	e1 f0       	breq	.+56     	; 0x6b8 <sensorMapping+0x54c>
 680:	80 91 86 00 	lds	r24, 0x0086
 684:	90 91 87 00 	lds	r25, 0x0087
 688:	88 38       	cpi	r24, 0x88	; 136
 68a:	91 05       	cpc	r25, r1
 68c:	a9 f0       	breq	.+42     	; 0x6b8 <sensorMapping+0x54c>
 68e:	80 91 86 00 	lds	r24, 0x0086
 692:	90 91 87 00 	lds	r25, 0x0087
 696:	8c 38       	cpi	r24, 0x8C	; 140
 698:	91 05       	cpc	r25, r1
 69a:	71 f0       	breq	.+28     	; 0x6b8 <sensorMapping+0x54c>
 69c:	80 91 86 00 	lds	r24, 0x0086
 6a0:	90 91 87 00 	lds	r25, 0x0087
 6a4:	8e 38       	cpi	r24, 0x8E	; 142
 6a6:	91 05       	cpc	r25, r1
 6a8:	39 f0       	breq	.+14     	; 0x6b8 <sensorMapping+0x54c>
 6aa:	80 91 86 00 	lds	r24, 0x0086
 6ae:	90 91 87 00 	lds	r25, 0x0087
 6b2:	86 3c       	cpi	r24, 0xC6	; 198
 6b4:	91 05       	cpc	r25, r1
 6b6:	31 f4       	brne	.+12     	; 0x6c4 <sensorMapping+0x558>
 6b8:	88 e8       	ldi	r24, 0x88	; 136
 6ba:	9f ef       	ldi	r25, 0xFF	; 255
 6bc:	90 93 85 00 	sts	0x0085, r25
 6c0:	80 93 84 00 	sts	0x0084, r24
 6c4:	08 95       	ret

000006c6 <Forward>:
	motor2b_PORT |= (1 << motor2b_PIN);
}

void Forward(void)
{
	enable1(0);
 6c6:	80 e0       	ldi	r24, 0x00	; 0
 6c8:	90 e0       	ldi	r25, 0x00	; 0
 6ca:	0e 94 18 05 	call	0xa30	; 0xa30 <PWM2>
	enable2(0);
 6ce:	80 e0       	ldi	r24, 0x00	; 0
 6d0:	90 e0       	ldi	r25, 0x00	; 0
 6d2:	0e 94 16 05 	call	0xa2c	; 0xa2c <PWM0>
	
	motor1a_PORT |= (1 << motor1a_PIN);
 6d6:	af 9a       	sbi	0x15, 7	; 21
	motor1b_PORT &= ~(1 << motor1b_PIN);
 6d8:	ae 98       	cbi	0x15, 6	; 21
	motor2a_PORT |= (1 << motor2a_PIN);
 6da:	ad 9a       	sbi	0x15, 5	; 21
	motor2b_PORT &= ~(1 << motor2b_PIN);
 6dc:	ac 98       	cbi	0x15, 4	; 21

	enable1(baseSpeed);
 6de:	84 eb       	ldi	r24, 0xB4	; 180
 6e0:	90 e0       	ldi	r25, 0x00	; 0
 6e2:	0e 94 18 05 	call	0xa30	; 0xa30 <PWM2>
	enable2(baseSpeed);
 6e6:	84 eb       	ldi	r24, 0xB4	; 180
 6e8:	90 e0       	ldi	r25, 0x00	; 0
 6ea:	0e 94 16 05 	call	0xa2c	; 0xa2c <PWM0>
 6ee:	08 95       	ret

000006f0 <Backward>:
}

void Backward(void)
{
	enable1(0);
 6f0:	80 e0       	ldi	r24, 0x00	; 0
 6f2:	90 e0       	ldi	r25, 0x00	; 0
 6f4:	0e 94 18 05 	call	0xa30	; 0xa30 <PWM2>
	enable2(0);
 6f8:	80 e0       	ldi	r24, 0x00	; 0
 6fa:	90 e0       	ldi	r25, 0x00	; 0
 6fc:	0e 94 16 05 	call	0xa2c	; 0xa2c <PWM0>
	
	motor1a_PORT &= ~(1 << motor1a_PIN);
 700:	af 98       	cbi	0x15, 7	; 21
	motor1b_PORT |= (1 << motor1b_PIN);
 702:	ae 9a       	sbi	0x15, 6	; 21
	motor2a_PORT &= ~(1 << motor2a_PIN);
 704:	ad 98       	cbi	0x15, 5	; 21
	motor2b_PORT |= (1 << motor2b_PIN);
 706:	ac 9a       	sbi	0x15, 4	; 21

	enable1(baseSpeed);
 708:	84 eb       	ldi	r24, 0xB4	; 180
 70a:	90 e0       	ldi	r25, 0x00	; 0
 70c:	0e 94 18 05 	call	0xa30	; 0xa30 <PWM2>
	enable2(baseSpeed);
 710:	84 eb       	ldi	r24, 0xB4	; 180
 712:	90 e0       	ldi	r25, 0x00	; 0
 714:	0e 94 16 05 	call	0xa2c	; 0xa2c <PWM0>
 718:	08 95       	ret

0000071a <RightSharp>:
}

void RightSharp(void)
{
	enable1(0);
 71a:	80 e0       	ldi	r24, 0x00	; 0
 71c:	90 e0       	ldi	r25, 0x00	; 0
 71e:	0e 94 18 05 	call	0xa30	; 0xa30 <PWM2>
	enable2(0);
 722:	80 e0       	ldi	r24, 0x00	; 0
 724:	90 e0       	ldi	r25, 0x00	; 0
 726:	0e 94 16 05 	call	0xa2c	; 0xa2c <PWM0>
	
	motor1a_PORT |= (1 << motor1a_PIN);
 72a:	af 9a       	sbi	0x15, 7	; 21
	motor1b_PORT &= ~(1 << motor1b_PIN);
 72c:	ae 98       	cbi	0x15, 6	; 21
	motor2a_PORT &= ~(1 << motor2a_PIN);
 72e:	ad 98       	cbi	0x15, 5	; 21
	motor2b_PORT |= (1 << motor2b_PIN);
 730:	ac 9a       	sbi	0x15, 4	; 21

	enable1(baseSpeed);
 732:	84 eb       	ldi	r24, 0xB4	; 180
 734:	90 e0       	ldi	r25, 0x00	; 0
 736:	0e 94 18 05 	call	0xa30	; 0xa30 <PWM2>
	enable2(baseSpeed);
 73a:	84 eb       	ldi	r24, 0xB4	; 180
 73c:	90 e0       	ldi	r25, 0x00	; 0
 73e:	0e 94 16 05 	call	0xa2c	; 0xa2c <PWM0>
 742:	08 95       	ret

00000744 <LeftSharp>:
}

void LeftSharp(void)
{
	enable1(0);
 744:	80 e0       	ldi	r24, 0x00	; 0
 746:	90 e0       	ldi	r25, 0x00	; 0
 748:	0e 94 18 05 	call	0xa30	; 0xa30 <PWM2>
	enable2(0);
 74c:	80 e0       	ldi	r24, 0x00	; 0
 74e:	90 e0       	ldi	r25, 0x00	; 0
 750:	0e 94 16 05 	call	0xa2c	; 0xa2c <PWM0>
	
	motor1a_PORT &= ~(1 << motor1a_PIN);
 754:	af 98       	cbi	0x15, 7	; 21
	motor1b_PORT |= (1 << motor1b_PIN);
 756:	ae 9a       	sbi	0x15, 6	; 21
	motor2a_PORT |= (1 << motor2a_PIN);
 758:	ad 9a       	sbi	0x15, 5	; 21
	motor2b_PORT &= ~(1 << motor2b_PIN);
 75a:	ac 98       	cbi	0x15, 4	; 21

	enable1(baseSpeed);
 75c:	84 eb       	ldi	r24, 0xB4	; 180
 75e:	90 e0       	ldi	r25, 0x00	; 0
 760:	0e 94 18 05 	call	0xa30	; 0xa30 <PWM2>
	enable2(baseSpeed);
 764:	84 eb       	ldi	r24, 0xB4	; 180
 766:	90 e0       	ldi	r25, 0x00	; 0
 768:	0e 94 16 05 	call	0xa2c	; 0xa2c <PWM0>
 76c:	08 95       	ret

0000076e <main>:

int main(void)
{
	// Input-Output settings
	
	trig1_DDR |= (1 << trig1_PIN);
 76e:	8c 9a       	sbi	0x11, 4	; 17
	trig2_DDR |= (1 << trig2_PIN);
 770:	8d 9a       	sbi	0x11, 5	; 17
	trig3_DDR |= (1 << trig3_PIN);
 772:	b9 9a       	sbi	0x17, 1	; 23
	echo1_DDR &= ~(1 << echo1_PIN);
 774:	8b 98       	cbi	0x11, 3	; 17
	echo2_DDR &= ~(1 << echo2_PIN);
 776:	8a 98       	cbi	0x11, 2	; 17
	echo3_DDR &= ~(1 << echo3_PIN);
 778:	ba 98       	cbi	0x17, 2	; 23
	motor1a_DDR |= (1 << motor1a_PIN);
 77a:	a7 9a       	sbi	0x14, 7	; 20
	motor1b_DDR |= (1 << motor1b_PIN);
 77c:	a6 9a       	sbi	0x14, 6	; 20
	motor2a_DDR |= (1 << motor2a_PIN);
 77e:	a5 9a       	sbi	0x14, 5	; 20
	motor2b_DDR |= (1 << motor2b_PIN);
 780:	a4 9a       	sbi	0x14, 4	; 20
	enable1_DDR |= (1 << enable1_PIN);
 782:	8f 9a       	sbi	0x11, 7	; 17
	enable2_DDR |= (1 << enable2_PIN);
 784:	bb 9a       	sbi	0x17, 3	; 23
	
//	uint8_t finishLevelCount = 0;
	
	// Initializations 
	
	adc_init();
 786:	0e 94 49 00 	call	0x92	; 0x92 <adc_init>
	UART_init();
 78a:	0e 94 1a 05 	call	0xa34	; 0xa34 <UART_init>
	PWM0_init();
 78e:	0e 94 02 05 	call	0xa04	; 0xa04 <PWM0_init>
	PWM2_init();
 792:	0e 94 0c 05 	call	0xa18	; 0xa18 <PWM2_init>
	
// 	xINT_init();
// 	TIMER0_2_INT_init();
// 	sei();
	
	Forward();
 796:	0e 94 63 03 	call	0x6c6	; 0x6c6 <Forward>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 79a:	2f ef       	ldi	r18, 0xFF	; 255
 79c:	87 ea       	ldi	r24, 0xA7	; 167
 79e:	91 e6       	ldi	r25, 0x61	; 97
 7a0:	21 50       	subi	r18, 0x01	; 1
 7a2:	80 40       	sbci	r24, 0x00	; 0
 7a4:	90 40       	sbci	r25, 0x00	; 0
 7a6:	e1 f7       	brne	.-8      	; 0x7a0 <main+0x32>
 7a8:	00 c0       	rjmp	.+0      	; 0x7aa <main+0x3c>
 7aa:	00 00       	nop
	_delay_ms(2000);
	Backward();
 7ac:	0e 94 78 03 	call	0x6f0	; 0x6f0 <Backward>
 7b0:	2f ef       	ldi	r18, 0xFF	; 255
 7b2:	87 ea       	ldi	r24, 0xA7	; 167
 7b4:	91 e6       	ldi	r25, 0x61	; 97
 7b6:	21 50       	subi	r18, 0x01	; 1
 7b8:	80 40       	sbci	r24, 0x00	; 0
 7ba:	90 40       	sbci	r25, 0x00	; 0
 7bc:	e1 f7       	brne	.-8      	; 0x7b6 <main+0x48>
 7be:	00 c0       	rjmp	.+0      	; 0x7c0 <main+0x52>
 7c0:	00 00       	nop
	_delay_ms(2000);
	RightSharp();
 7c2:	0e 94 8d 03 	call	0x71a	; 0x71a <RightSharp>
 7c6:	2f ef       	ldi	r18, 0xFF	; 255
 7c8:	87 ea       	ldi	r24, 0xA7	; 167
 7ca:	91 e6       	ldi	r25, 0x61	; 97
 7cc:	21 50       	subi	r18, 0x01	; 1
 7ce:	80 40       	sbci	r24, 0x00	; 0
 7d0:	90 40       	sbci	r25, 0x00	; 0
 7d2:	e1 f7       	brne	.-8      	; 0x7cc <main+0x5e>
 7d4:	00 c0       	rjmp	.+0      	; 0x7d6 <main+0x68>
 7d6:	00 00       	nop
	_delay_ms(2000);
	LeftSharp();
 7d8:	0e 94 a2 03 	call	0x744	; 0x744 <LeftSharp>
 7dc:	2f ef       	ldi	r18, 0xFF	; 255
 7de:	87 ea       	ldi	r24, 0xA7	; 167
 7e0:	91 e6       	ldi	r25, 0x61	; 97
 7e2:	21 50       	subi	r18, 0x01	; 1
 7e4:	80 40       	sbci	r24, 0x00	; 0
 7e6:	90 40       	sbci	r25, 0x00	; 0
 7e8:	e1 f7       	brne	.-8      	; 0x7e2 <main+0x74>
 7ea:	00 c0       	rjmp	.+0      	; 0x7ec <main+0x7e>
 7ec:	00 00       	nop
	_delay_ms(2000);
	Forward();
 7ee:	0e 94 63 03 	call	0x6c6	; 0x6c6 <Forward>
 7f2:	2f ef       	ldi	r18, 0xFF	; 255
 7f4:	87 ea       	ldi	r24, 0xA7	; 167
 7f6:	91 e6       	ldi	r25, 0x61	; 97
 7f8:	21 50       	subi	r18, 0x01	; 1
 7fa:	80 40       	sbci	r24, 0x00	; 0
 7fc:	90 40       	sbci	r25, 0x00	; 0
 7fe:	e1 f7       	brne	.-8      	; 0x7f8 <main+0x8a>
 800:	00 c0       	rjmp	.+0      	; 0x802 <main+0x94>
 802:	00 00       	nop
	_delay_ms(2000);
	
    while (1) 
    {
		sensorValueConversion();
 804:	0e 94 5b 00 	call	0xb6	; 0xb6 <sensorValueConversion>
		sensorMapping();
 808:	0e 94 b6 00 	call	0x16c	; 0x16c <sensorMapping>
// 		}
// 		 				
// 		PID_Correction();
// 		enable1(LMspeed);
// 		enable2(RMspeed);
	}
 80c:	fb cf       	rjmp	.-10     	; 0x804 <main+0x96>

0000080e <__vector_1>:
{
	TIMSK |= (1 << TOIE2) | (1 << TOIE0);				// Enable Timer Overflow Interrupt 0, Timer Overflow Interrupt 2
}

ISR (INT0_vect)
{
 80e:	1f 92       	push	r1
 810:	0f 92       	push	r0
 812:	0f b6       	in	r0, 0x3f	; 63
 814:	0f 92       	push	r0
 816:	11 24       	eor	r1, r1
 818:	8f 93       	push	r24
 81a:	9f 93       	push	r25
	if (choice1 == 0)
 81c:	80 91 80 00 	lds	r24, 0x0080
 820:	90 91 81 00 	lds	r25, 0x0081
 824:	89 2b       	or	r24, r25
 826:	51 f4       	brne	.+20     	; 0x83c <__vector_1+0x2e>
	{
		TCCR1B |= (1 << CS11);
 828:	8e b5       	in	r24, 0x2e	; 46
 82a:	82 60       	ori	r24, 0x02	; 2
 82c:	8e bd       	out	0x2e, r24	; 46
		choice1 = 1;
 82e:	81 e0       	ldi	r24, 0x01	; 1
 830:	90 e0       	ldi	r25, 0x00	; 0
 832:	90 93 81 00 	sts	0x0081, r25
 836:	80 93 80 00 	sts	0x0080, r24
 83a:	15 c0       	rjmp	.+42     	; 0x866 <__stack+0x7>
	}
	else if (choice1 == 1)
 83c:	80 91 80 00 	lds	r24, 0x0080
 840:	90 91 81 00 	lds	r25, 0x0081
 844:	01 97       	sbiw	r24, 0x01	; 1
 846:	79 f4       	brne	.+30     	; 0x866 <__stack+0x7>
	{
		TCCR1B = 0;
 848:	1e bc       	out	0x2e, r1	; 46
		pulse1 = TCNT1 / 2;
 84a:	8c b5       	in	r24, 0x2c	; 44
 84c:	9d b5       	in	r25, 0x2d	; 45
 84e:	96 95       	lsr	r25
 850:	87 95       	ror	r24
 852:	90 93 83 00 	sts	0x0083, r25
 856:	80 93 82 00 	sts	0x0082, r24
		TCNT1 = 0;
 85a:	1d bc       	out	0x2d, r1	; 45
 85c:	1c bc       	out	0x2c, r1	; 44
		choice1 = 0;
 85e:	10 92 81 00 	sts	0x0081, r1
 862:	10 92 80 00 	sts	0x0080, r1
	}
}
 866:	9f 91       	pop	r25
 868:	8f 91       	pop	r24
 86a:	0f 90       	pop	r0
 86c:	0f be       	out	0x3f, r0	; 63
 86e:	0f 90       	pop	r0
 870:	1f 90       	pop	r1
 872:	18 95       	reti

00000874 <__vector_2>:

ISR (INT1_vect)
{
 874:	1f 92       	push	r1
 876:	0f 92       	push	r0
 878:	0f b6       	in	r0, 0x3f	; 63
 87a:	0f 92       	push	r0
 87c:	11 24       	eor	r1, r1
 87e:	2f 93       	push	r18
 880:	3f 93       	push	r19
 882:	4f 93       	push	r20
 884:	5f 93       	push	r21
 886:	8f 93       	push	r24
 888:	9f 93       	push	r25
	if (choice2 == 0)
 88a:	80 91 7c 00 	lds	r24, 0x007C
 88e:	90 91 7d 00 	lds	r25, 0x007D
 892:	89 2b       	or	r24, r25
 894:	51 f4       	brne	.+20     	; 0x8aa <__vector_2+0x36>
	{
		TCCR0 |= 0b00000011;
 896:	83 b7       	in	r24, 0x33	; 51
 898:	83 60       	ori	r24, 0x03	; 3
 89a:	83 bf       	out	0x33, r24	; 51
		choice2 = 1;
 89c:	81 e0       	ldi	r24, 0x01	; 1
 89e:	90 e0       	ldi	r25, 0x00	; 0
 8a0:	90 93 7d 00 	sts	0x007D, r25
 8a4:	80 93 7c 00 	sts	0x007C, r24
 8a8:	25 c0       	rjmp	.+74     	; 0x8f4 <__vector_2+0x80>
	}
	else if (choice2 == 1)
 8aa:	80 91 7c 00 	lds	r24, 0x007C
 8ae:	90 91 7d 00 	lds	r25, 0x007D
 8b2:	01 97       	sbiw	r24, 0x01	; 1
 8b4:	f9 f4       	brne	.+62     	; 0x8f4 <__vector_2+0x80>
	{
		TCCR0 = 0;
 8b6:	13 be       	out	0x33, r1	; 51
		pulse2 = (TCNT0 + (0xFF * TIMER0_INT)) * 4;
 8b8:	22 b7       	in	r18, 0x32	; 50
 8ba:	40 91 76 00 	lds	r20, 0x0076
 8be:	50 91 77 00 	lds	r21, 0x0077
 8c2:	3f ef       	ldi	r19, 0xFF	; 255
 8c4:	34 9f       	mul	r19, r20
 8c6:	c0 01       	movw	r24, r0
 8c8:	35 9f       	mul	r19, r21
 8ca:	90 0d       	add	r25, r0
 8cc:	11 24       	eor	r1, r1
 8ce:	82 0f       	add	r24, r18
 8d0:	91 1d       	adc	r25, r1
 8d2:	88 0f       	add	r24, r24
 8d4:	99 1f       	adc	r25, r25
 8d6:	88 0f       	add	r24, r24
 8d8:	99 1f       	adc	r25, r25
 8da:	90 93 7f 00 	sts	0x007F, r25
 8de:	80 93 7e 00 	sts	0x007E, r24
		TIMER0_INT = 0;
 8e2:	10 92 77 00 	sts	0x0077, r1
 8e6:	10 92 76 00 	sts	0x0076, r1
		TCNT0 = 0;
 8ea:	12 be       	out	0x32, r1	; 50
		choice2 = 0;
 8ec:	10 92 7d 00 	sts	0x007D, r1
 8f0:	10 92 7c 00 	sts	0x007C, r1
	}
}
 8f4:	9f 91       	pop	r25
 8f6:	8f 91       	pop	r24
 8f8:	5f 91       	pop	r21
 8fa:	4f 91       	pop	r20
 8fc:	3f 91       	pop	r19
 8fe:	2f 91       	pop	r18
 900:	0f 90       	pop	r0
 902:	0f be       	out	0x3f, r0	; 63
 904:	0f 90       	pop	r0
 906:	1f 90       	pop	r1
 908:	18 95       	reti

0000090a <__vector_3>:

ISR (INT2_vect)
{
 90a:	1f 92       	push	r1
 90c:	0f 92       	push	r0
 90e:	0f b6       	in	r0, 0x3f	; 63
 910:	0f 92       	push	r0
 912:	11 24       	eor	r1, r1
 914:	2f 93       	push	r18
 916:	3f 93       	push	r19
 918:	4f 93       	push	r20
 91a:	5f 93       	push	r21
 91c:	8f 93       	push	r24
 91e:	9f 93       	push	r25
	MCUCSR ^= (1 << ISC2);
 920:	94 b7       	in	r25, 0x34	; 52
 922:	80 e4       	ldi	r24, 0x40	; 64
 924:	89 27       	eor	r24, r25
 926:	84 bf       	out	0x34, r24	; 52
	if (choice3 == 0)
 928:	80 91 78 00 	lds	r24, 0x0078
 92c:	90 91 79 00 	lds	r25, 0x0079
 930:	89 2b       	or	r24, r25
 932:	51 f4       	brne	.+20     	; 0x948 <__vector_3+0x3e>
	{
		TCCR2 |= 0b00000100;
 934:	85 b5       	in	r24, 0x25	; 37
 936:	84 60       	ori	r24, 0x04	; 4
 938:	85 bd       	out	0x25, r24	; 37
		choice3 = 1;
 93a:	81 e0       	ldi	r24, 0x01	; 1
 93c:	90 e0       	ldi	r25, 0x00	; 0
 93e:	90 93 79 00 	sts	0x0079, r25
 942:	80 93 78 00 	sts	0x0078, r24
 946:	25 c0       	rjmp	.+74     	; 0x992 <__vector_3+0x88>
	}
	else if (choice3 == 1)
 948:	80 91 78 00 	lds	r24, 0x0078
 94c:	90 91 79 00 	lds	r25, 0x0079
 950:	01 97       	sbiw	r24, 0x01	; 1
 952:	f9 f4       	brne	.+62     	; 0x992 <__vector_3+0x88>
	{
		TCCR2 = 0;
 954:	15 bc       	out	0x25, r1	; 37
		pulse3 = (TCNT2 + (0xFF * TIMER2_INT)) * 4;
 956:	24 b5       	in	r18, 0x24	; 36
 958:	40 91 74 00 	lds	r20, 0x0074
 95c:	50 91 75 00 	lds	r21, 0x0075
 960:	3f ef       	ldi	r19, 0xFF	; 255
 962:	34 9f       	mul	r19, r20
 964:	c0 01       	movw	r24, r0
 966:	35 9f       	mul	r19, r21
 968:	90 0d       	add	r25, r0
 96a:	11 24       	eor	r1, r1
 96c:	82 0f       	add	r24, r18
 96e:	91 1d       	adc	r25, r1
 970:	88 0f       	add	r24, r24
 972:	99 1f       	adc	r25, r25
 974:	88 0f       	add	r24, r24
 976:	99 1f       	adc	r25, r25
 978:	90 93 7b 00 	sts	0x007B, r25
 97c:	80 93 7a 00 	sts	0x007A, r24
		TIMER2_INT = 0;
 980:	10 92 75 00 	sts	0x0075, r1
 984:	10 92 74 00 	sts	0x0074, r1
		TCNT2 = 0;
 988:	14 bc       	out	0x24, r1	; 36
		choice3 = 0;
 98a:	10 92 79 00 	sts	0x0079, r1
 98e:	10 92 78 00 	sts	0x0078, r1
	}
}
 992:	9f 91       	pop	r25
 994:	8f 91       	pop	r24
 996:	5f 91       	pop	r21
 998:	4f 91       	pop	r20
 99a:	3f 91       	pop	r19
 99c:	2f 91       	pop	r18
 99e:	0f 90       	pop	r0
 9a0:	0f be       	out	0x3f, r0	; 63
 9a2:	0f 90       	pop	r0
 9a4:	1f 90       	pop	r1
 9a6:	18 95       	reti

000009a8 <__vector_5>:

ISR (TIMER2_OVF_vect)
{
 9a8:	1f 92       	push	r1
 9aa:	0f 92       	push	r0
 9ac:	0f b6       	in	r0, 0x3f	; 63
 9ae:	0f 92       	push	r0
 9b0:	11 24       	eor	r1, r1
 9b2:	8f 93       	push	r24
 9b4:	9f 93       	push	r25
	TIMER2_INT++;
 9b6:	80 91 74 00 	lds	r24, 0x0074
 9ba:	90 91 75 00 	lds	r25, 0x0075
 9be:	01 96       	adiw	r24, 0x01	; 1
 9c0:	90 93 75 00 	sts	0x0075, r25
 9c4:	80 93 74 00 	sts	0x0074, r24
}
 9c8:	9f 91       	pop	r25
 9ca:	8f 91       	pop	r24
 9cc:	0f 90       	pop	r0
 9ce:	0f be       	out	0x3f, r0	; 63
 9d0:	0f 90       	pop	r0
 9d2:	1f 90       	pop	r1
 9d4:	18 95       	reti

000009d6 <__vector_11>:

ISR (TIMER0_OVF_vect)
{
 9d6:	1f 92       	push	r1
 9d8:	0f 92       	push	r0
 9da:	0f b6       	in	r0, 0x3f	; 63
 9dc:	0f 92       	push	r0
 9de:	11 24       	eor	r1, r1
 9e0:	8f 93       	push	r24
 9e2:	9f 93       	push	r25
	TIMER0_INT++;
 9e4:	80 91 76 00 	lds	r24, 0x0076
 9e8:	90 91 77 00 	lds	r25, 0x0077
 9ec:	01 96       	adiw	r24, 0x01	; 1
 9ee:	90 93 77 00 	sts	0x0077, r25
 9f2:	80 93 76 00 	sts	0x0076, r24
}
 9f6:	9f 91       	pop	r25
 9f8:	8f 91       	pop	r24
 9fa:	0f 90       	pop	r0
 9fc:	0f be       	out	0x3f, r0	; 63
 9fe:	0f 90       	pop	r0
 a00:	1f 90       	pop	r1
 a02:	18 95       	reti

00000a04 <PWM0_init>:
 a04:	83 b7       	in	r24, 0x33	; 51
 a06:	88 64       	ori	r24, 0x48	; 72
 a08:	83 bf       	out	0x33, r24	; 51
 a0a:	83 b7       	in	r24, 0x33	; 51
 a0c:	80 62       	ori	r24, 0x20	; 32
 a0e:	83 bf       	out	0x33, r24	; 51
 a10:	83 b7       	in	r24, 0x33	; 51
 a12:	81 60       	ori	r24, 0x01	; 1
 a14:	83 bf       	out	0x33, r24	; 51
 a16:	08 95       	ret

00000a18 <PWM2_init>:
 a18:	85 b5       	in	r24, 0x25	; 37
 a1a:	88 64       	ori	r24, 0x48	; 72
 a1c:	85 bd       	out	0x25, r24	; 37
 a1e:	85 b5       	in	r24, 0x25	; 37
 a20:	80 62       	ori	r24, 0x20	; 32
 a22:	85 bd       	out	0x25, r24	; 37
 a24:	85 b5       	in	r24, 0x25	; 37
 a26:	81 60       	ori	r24, 0x01	; 1
 a28:	85 bd       	out	0x25, r24	; 37
 a2a:	08 95       	ret

00000a2c <PWM0>:
 a2c:	8c bf       	out	0x3c, r24	; 60
 a2e:	08 95       	ret

00000a30 <PWM2>:
 a30:	83 bd       	out	0x23, r24	; 35
 a32:	08 95       	ret

00000a34 <UART_init>:
 a34:	80 b5       	in	r24, 0x20	; 32
 a36:	8f 7b       	andi	r24, 0xBF	; 191
 a38:	80 bd       	out	0x20, r24	; 32
 a3a:	59 98       	cbi	0x0b, 1	; 11
 a3c:	10 bc       	out	0x20, r1	; 32
 a3e:	87 e6       	ldi	r24, 0x67	; 103
 a40:	89 b9       	out	0x09, r24	; 9
 a42:	8a b1       	in	r24, 0x0a	; 10
 a44:	88 61       	ori	r24, 0x18	; 24
 a46:	8a b9       	out	0x0a, r24	; 10
 a48:	80 b5       	in	r24, 0x20	; 32
 a4a:	8e 68       	ori	r24, 0x8E	; 142
 a4c:	80 bd       	out	0x20, r24	; 32
 a4e:	08 95       	ret

00000a50 <Serial_sendChar>:
 a50:	5d 9b       	sbis	0x0b, 5	; 11
 a52:	fe cf       	rjmp	.-4      	; 0xa50 <Serial_sendChar>
 a54:	8c b9       	out	0x0c, r24	; 12
 a56:	08 95       	ret

00000a58 <Serial_sendString>:
 a58:	cf 93       	push	r28
 a5a:	df 93       	push	r29
 a5c:	ec 01       	movw	r28, r24
 a5e:	88 81       	ld	r24, Y
 a60:	88 23       	and	r24, r24
 a62:	31 f0       	breq	.+12     	; 0xa70 <Serial_sendString+0x18>
 a64:	21 96       	adiw	r28, 0x01	; 1
 a66:	0e 94 28 05 	call	0xa50	; 0xa50 <Serial_sendChar>
 a6a:	89 91       	ld	r24, Y+
 a6c:	81 11       	cpse	r24, r1
 a6e:	fb cf       	rjmp	.-10     	; 0xa66 <Serial_sendString+0xe>
 a70:	df 91       	pop	r29
 a72:	cf 91       	pop	r28
 a74:	08 95       	ret

00000a76 <Serial_sendInt>:
 a76:	cf 93       	push	r28
 a78:	df 93       	push	r29
 a7a:	cd b7       	in	r28, 0x3d	; 61
 a7c:	de b7       	in	r29, 0x3e	; 62
 a7e:	60 97       	sbiw	r28, 0x10	; 16
 a80:	0f b6       	in	r0, 0x3f	; 63
 a82:	f8 94       	cli
 a84:	de bf       	out	0x3e, r29	; 62
 a86:	0f be       	out	0x3f, r0	; 63
 a88:	cd bf       	out	0x3d, r28	; 61
 a8a:	ab 01       	movw	r20, r22
 a8c:	5d 9b       	sbis	0x0b, 5	; 11
 a8e:	fe cf       	rjmp	.-4      	; 0xa8c <Serial_sendInt+0x16>
extern __inline__ __ATTR_GNU_INLINE__
char *itoa (int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__itoa (int, char *, int);
	return __itoa (__val, __s, __radix);
 a90:	be 01       	movw	r22, r28
 a92:	6f 5f       	subi	r22, 0xFF	; 255
 a94:	7f 4f       	sbci	r23, 0xFF	; 255
 a96:	0e 94 5a 05 	call	0xab4	; 0xab4 <itoa>
 a9a:	ce 01       	movw	r24, r28
 a9c:	01 96       	adiw	r24, 0x01	; 1
 a9e:	0e 94 2c 05 	call	0xa58	; 0xa58 <Serial_sendString>
 aa2:	60 96       	adiw	r28, 0x10	; 16
 aa4:	0f b6       	in	r0, 0x3f	; 63
 aa6:	f8 94       	cli
 aa8:	de bf       	out	0x3e, r29	; 62
 aaa:	0f be       	out	0x3f, r0	; 63
 aac:	cd bf       	out	0x3d, r28	; 61
 aae:	df 91       	pop	r29
 ab0:	cf 91       	pop	r28
 ab2:	08 95       	ret

00000ab4 <itoa>:
 ab4:	45 32       	cpi	r20, 0x25	; 37
 ab6:	51 05       	cpc	r21, r1
 ab8:	20 f4       	brcc	.+8      	; 0xac2 <itoa+0xe>
 aba:	42 30       	cpi	r20, 0x02	; 2
 abc:	10 f0       	brcs	.+4      	; 0xac2 <itoa+0xe>
 abe:	0c 94 65 05 	jmp	0xaca	; 0xaca <__itoa_ncheck>
 ac2:	fb 01       	movw	r30, r22
 ac4:	10 82       	st	Z, r1
 ac6:	cb 01       	movw	r24, r22
 ac8:	08 95       	ret

00000aca <__itoa_ncheck>:
 aca:	bb 27       	eor	r27, r27
 acc:	4a 30       	cpi	r20, 0x0A	; 10
 ace:	31 f4       	brne	.+12     	; 0xadc <__itoa_ncheck+0x12>
 ad0:	99 23       	and	r25, r25
 ad2:	22 f4       	brpl	.+8      	; 0xadc <__itoa_ncheck+0x12>
 ad4:	bd e2       	ldi	r27, 0x2D	; 45
 ad6:	90 95       	com	r25
 ad8:	81 95       	neg	r24
 ada:	9f 4f       	sbci	r25, 0xFF	; 255
 adc:	0c 94 71 05 	jmp	0xae2	; 0xae2 <__utoa_common>

00000ae0 <__utoa_ncheck>:
 ae0:	bb 27       	eor	r27, r27

00000ae2 <__utoa_common>:
 ae2:	fb 01       	movw	r30, r22
 ae4:	55 27       	eor	r21, r21
 ae6:	aa 27       	eor	r26, r26
 ae8:	88 0f       	add	r24, r24
 aea:	99 1f       	adc	r25, r25
 aec:	aa 1f       	adc	r26, r26
 aee:	a4 17       	cp	r26, r20
 af0:	10 f0       	brcs	.+4      	; 0xaf6 <__utoa_common+0x14>
 af2:	a4 1b       	sub	r26, r20
 af4:	83 95       	inc	r24
 af6:	50 51       	subi	r21, 0x10	; 16
 af8:	b9 f7       	brne	.-18     	; 0xae8 <__utoa_common+0x6>
 afa:	a0 5d       	subi	r26, 0xD0	; 208
 afc:	aa 33       	cpi	r26, 0x3A	; 58
 afe:	08 f0       	brcs	.+2      	; 0xb02 <__utoa_common+0x20>
 b00:	a9 5d       	subi	r26, 0xD9	; 217
 b02:	a1 93       	st	Z+, r26
 b04:	00 97       	sbiw	r24, 0x00	; 0
 b06:	79 f7       	brne	.-34     	; 0xae6 <__utoa_common+0x4>
 b08:	b1 11       	cpse	r27, r1
 b0a:	b1 93       	st	Z+, r27
 b0c:	11 92       	st	Z+, r1
 b0e:	cb 01       	movw	r24, r22
 b10:	0c 94 8a 05 	jmp	0xb14	; 0xb14 <strrev>

00000b14 <strrev>:
 b14:	dc 01       	movw	r26, r24
 b16:	fc 01       	movw	r30, r24
 b18:	67 2f       	mov	r22, r23
 b1a:	71 91       	ld	r23, Z+
 b1c:	77 23       	and	r23, r23
 b1e:	e1 f7       	brne	.-8      	; 0xb18 <strrev+0x4>
 b20:	32 97       	sbiw	r30, 0x02	; 2
 b22:	04 c0       	rjmp	.+8      	; 0xb2c <strrev+0x18>
 b24:	7c 91       	ld	r23, X
 b26:	6d 93       	st	X+, r22
 b28:	70 83       	st	Z, r23
 b2a:	62 91       	ld	r22, -Z
 b2c:	ae 17       	cp	r26, r30
 b2e:	bf 07       	cpc	r27, r31
 b30:	c8 f3       	brcs	.-14     	; 0xb24 <strrev+0x10>
 b32:	08 95       	ret

00000b34 <_exit>:
 b34:	f8 94       	cli

00000b36 <__stop_program>:
 b36:	ff cf       	rjmp	.-2      	; 0xb36 <__stop_program>
